# 硬件结构

## CPU是如何执行程序的？
### 图灵机
### 冯诺依曼模型
1. 运算器、控制器、存储器、输入设备、输出设备
### 基础知识
1. 计算机存储数据的基本单位是字节，
2. 内存，存储区域线性（数组），每个字节对应一个内存地址
3. 中央处理器（CPU），CPU内部组件==寄存器==、==控制单元==和==逻辑运算单元==等
4. 总线，用于CPU和内存以及其他设备之间的通信（地址总线、数据总线、控制总线）
5. 线路位宽表示**数据总线一次能传输的位数**，CPU位宽表示**处理器一次能处理的数据位数**
6. 简单讲讲一个程序执行过程：一个程序执行的时候，CPU会根据程序计数器里的内存地址，从内存里面把需要执行的指令读到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令
7. CPU从指令计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为**CPU的指令周期**
8. 指令、指令的类型、指令的执行速度
   - 指令的内容是一串二进制数字的机器码，每条指令都有对应的机器码，CPU通过解析机器码来知道指令内容
   - 不同的 CPU 有不同的指令集，也就是对应着不同的汇编语言和不同的机器码
   - a = 1 + 1 一共有四步

### 存储器的层次结构

### CPU的一系列特性

CPU - CPU Cache - 内存

CPU Cache  = many Cache Lines 


缓存一致性，讲解，如何执行任务的？

### 软中断

中断处理程序的下半部，内核出发，通常是耗时比较长的任务，特点是延迟执行

# 操作系统结构

### 内核
作为应用连接硬件设备的桥梁，应用程序只需关心与内核交互，不用关心硬件细节

###### 内核能力
1. 管理进程、线程，进程调度，决定哪个使用CPU
2. 管理内存，决定内存的分配和回收
3. 管理硬件设备，硬件通信能力
4. 提供系统调用，用户程序与操作系统之间的接口

###### 内核工作空间
内存分为：
1. 内核空间（权限高，内核态）
2. 用户空间（权限低，用户态）
应用程序通过系统调用进入内核空间提权（里面包含两个中断）

### Linux
- 多任务，MultiTask
- SMP，对称多处理
- ELF，可执行文件链接格式
- Monolithic Kernel， 宏内核

### Windows
- 混合型内核 - 宏内核 + 微内核
- 可执行文件格式为 PE

# 内存管理

### 虚拟内存

###### 1. 基本介绍
- 每个进程只需要操作自己的虚拟内存地址就行，不用管物理地址
- 操作系统会提供一种机制，将不同进程的虚拟地址和不用内存的物理地址映射起来

我们在程序所使用的内存地址叫做虚拟内存地址，
实际存在硬件里的空间地址叫做物理内存地址
###### 2. 内存分段和内存分页
- **内存分段**：段选择因子和段内偏移量，产生连续的内存空间
	- **内部内存碎片**：内存交换
- **内存分页**
	- 解决外部内存碎片和内存叫交换效率低
	- 一页固定大小
	- 页表映射虚拟地址和物理地址

###### 3. 段页式内存管理
	TODO


### 内存满了会发生什么？

###### 1. 在4GB物理内存机器上申请8G内存会怎样？
- 32位机器，一般失败，`cannot allocate memory`
- 64位机器，看`overcommit_memory`参数（linux）
- swap，TODO
###### 2. Swap机制的作用


### 如何避免预读失败和缓存污染的问题？

**是什么**
1. 程序在访问内存或磁盘数据时，往往是“局部性原理”的，所以系统会提前加载（预读）相邻的数据块
```
程序访问Ap[0], 预读A[1],A[2]以减少I/O时间
程序可能没有访问数据，导致白白浪费内存或I/O带宽
这就是预读失败
```
2. 无用或低频访问的数据占据了缓存空间，把真正常用的数据挤出去了
```
访问A[0...63] // 高频
访问B[0...4095] // 一次性读取一大块，把A挤掉
导致访问A时又要重新从内存加载，性能反而下降
这就是污染缓存
```

**怎么办**

1. Linux和MySQL的缓存
2. 传统LRU
3. 预读失败怎么办
4. 缓存污染怎么办





# 进程管理


# 调度算法

### 进程调度（CPU调度算法）

> 当CPU空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配CPU

Timing，当进程：
1. 运行到等待
2. 运行到就绪
3. 等待到就绪
4. 运行到终止
非抢占式：1，4； 抢占式：2，3；

> TODO
